.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Gearman::XS::Client 3"
.TH Gearman::XS::Client 3 "2013-04-20" "perl v5.14.4" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Gearman::XS::Client \- Perl client for gearman using libgearman
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Gearman::XS qw(:constants);
\&  use Gearman::XS::Client;
\&
\&  $client = new Gearman::XS::Client;
\&
\&  $ret = $client\->add_server($host, $port);
\&  if ($ret != GEARMAN_SUCCESS)
\&  {
\&    printf(STDERR "%s\en", $client\->error());
\&    exit(1);
\&  }
\&
\&  # single client interface
\&  ($ret, $result) = $client\->do("reverse", \*(Aqteststring\*(Aq);
\&  if ($ret == GEARMAN_SUCCESS)
\&  {
\&    printf("Result=%s\en", $result);
\&  }
\&
\&  # background client interface
\&  ($ret, $job_handle) = $client\->do_background(\*(Aqreverse\*(Aq, \*(Aqteststring);
\&  if ($ret != GEARMAN_SUCCESS)
\&  {
\&    printf(STDERR "%s\en", $client\->error());
\&    exit(1);
\&  }
\&
\&  # concurrent client interface
\&  ($ret, $task) = $client\->add_task(\*(Aqreverse\*(Aq, \*(Aqtest1\*(Aq);
\&  ($ret, $task) = $client\->add_task(\*(Aqreverse\*(Aq, \*(Aqtest2\*(Aq);
\&
\&  $ret = $client\->run_tasks();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Gearman::XS::Client is a client class for the Gearman distributed job system
using libgearman.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "Gearman::XS::Client\->\fInew()\fP"
.IX Subsection "Gearman::XS::Client->new()"
Returns a Gearman::XS::Client object.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$client\->add_server($host, $port)"
.el .SS "\f(CW$client\fP\->add_server($host, \f(CW$port\fP)"
.IX Subsection "$client->add_server($host, $port)"
Add a job server to a client. This goes into a list of servers than can be
used to run tasks. No socket I/O happens here, it is just added to a list.
Returns a standard gearman return value.
.ie n .SS "$client\->add_servers($servers)"
.el .SS "\f(CW$client\fP\->add_servers($servers)"
.IX Subsection "$client->add_servers($servers)"
Add a list of job servers to a client. The format for the server list is:
SERVER[:PORT][,SERVER[:PORT]]... No socket I/O happens here, it is just added
to a list. Returns a standard gearman return value.
.ie n .SS "$client\->\fIremove_servers()\fP"
.el .SS "\f(CW$client\fP\->\fIremove_servers()\fP"
.IX Subsection "$client->remove_servers()"
Remove all servers currently associated with the client.
.ie n .SS "$client\->\fIoptions()\fP"
.el .SS "\f(CW$client\fP\->\fIoptions()\fP"
.IX Subsection "$client->options()"
Get options for a client.
.ie n .SS "$client\->set_options($options)"
.el .SS "\f(CW$client\fP\->set_options($options)"
.IX Subsection "$client->set_options($options)"
Set options for a client.
.ie n .SS "$client\->add_options($options)"
.el .SS "\f(CW$client\fP\->add_options($options)"
.IX Subsection "$client->add_options($options)"
Add options for a client.
.ie n .SS "$client\->remove_options($options)"
.el .SS "\f(CW$client\fP\->remove_options($options)"
.IX Subsection "$client->remove_options($options)"
Remove options for a client.
.ie n .SS "$client\->\fItimeout()\fP"
.el .SS "\f(CW$client\fP\->\fItimeout()\fP"
.IX Subsection "$client->timeout()"
Get current socket I/O activity timeout value. Returns Timeout in milliseconds
to wait for I/O activity.
.ie n .SS "$client\->set_timeout($timeout)"
.el .SS "\f(CW$client\fP\->set_timeout($timeout)"
.IX Subsection "$client->set_timeout($timeout)"
Set socket I/O activity timeout for connections in milliseconds.
.ie n .SS "$client\->echo($data)"
.el .SS "\f(CW$client\fP\->echo($data)"
.IX Subsection "$client->echo($data)"
Send data to all job servers to see if they echo it back. This is a test
function to see if job servers are responding properly.
Returns a standard gearman return value.
.ie n .SS "$client\->do($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do($function_name, $workload)"
Run a single task and return a list with two entries: the first is a standard
gearman return value, the second is the result.
.ie n .SS "$client\->do_high($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do_high($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do_high($function_name, $workload)"
Run a high priority task and return a list with two entries: the first is a
standard gearman return value, the second is the result.
.ie n .SS "$client\->do_low($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do_low($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do_low($function_name, $workload)"
Run a low priority task and return a list with two entries: the first is a
standard gearman return value, the second is the result.
.ie n .SS "$client\->do_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do_background($function_name, $workload)"
Run a task in the background and return a list with two entries: the first is a
standard gearman return value, the second is the job handle.
.ie n .SS "$client\->do_high_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do_high_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do_high_background($function_name, $workload)"
Run a high priority task in the background and return a list with two entries:
the first is a standard gearman return value, the second is the job handle.
.ie n .SS "$client\->do_low_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->do_low_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->do_low_background($function_name, $workload)"
Run a low priority task in the background and return a list with two entries:
the first is a standard gearman return value, the second is the job handle.
.ie n .SS "$client\->add_task($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task($function_name, $workload)"
Add a task to be run in parallel and return a list with two entries:
the first is a standard gearman return value, the second is a Gearman::XS::Task
object.
.ie n .SS "$client\->add_task_high($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task_high($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task_high($function_name, $workload)"
Add a high priority task to be run in parallel and return a list with two
entries: the first is a standard gearman return value, the second is a
Gearman::XS::Task object.
.ie n .SS "$client\->add_task_low($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task_low($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task_low($function_name, $workload)"
Add a low priority task to be run in parallel and return a list with two
entries: the first is a standard gearman return value, the second is a
Gearman::XS::Task object.
.ie n .SS "$client\->add_task_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task_background($function_name, $workload)"
Add a background task to be run in parallel and return a list with two entries:
the first is a standard gearman return value, the second is a Gearman::XS::Task
object.
.ie n .SS "$client\->add_task_high_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task_high_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task_high_background($function_name, $workload)"
Add a high priority background task to be run in parallel and return a list
with two entries: the first is a standard gearman return value, the second is a
Gearman::XS::Task object.
.ie n .SS "$client\->add_task_low_background($function_name, $workload)"
.el .SS "\f(CW$client\fP\->add_task_low_background($function_name, \f(CW$workload\fP)"
.IX Subsection "$client->add_task_low_background($function_name, $workload)"
Add a low priority background task to be run in parallel and return a list
with two entries: the first is a standard gearman return value, the second is a
Gearman::XS::Task object.
.ie n .SS "$client\->add_task_status($job_handle)"
.el .SS "\f(CW$client\fP\->add_task_status($job_handle)"
.IX Subsection "$client->add_task_status($job_handle)"
Add task to get the status for a background task in parallel and return a list
with two entries: the first is a standard gearman return value, the second is a
Gearman::XS::Task object.
.ie n .SS "$client\->\fIrun_tasks()\fP"
.el .SS "\f(CW$client\fP\->\fIrun_tasks()\fP"
.IX Subsection "$client->run_tasks()"
Run tasks that have been added in parallel. Returns a standard gearman return
value.
.ie n .SS "$client\->set_created_fn($subref)"
.el .SS "\f(CW$client\fP\->set_created_fn($subref)"
.IX Subsection "$client->set_created_fn($subref)"
Set callback function when a job has been created for a task. No return value.
.ie n .SS "$client\->set_data_fn($subref)"
.el .SS "\f(CW$client\fP\->set_data_fn($subref)"
.IX Subsection "$client->set_data_fn($subref)"
Set callback function when there is a data packet for a task. No return value.
.ie n .SS "$client\->set_complete_fn($subref)"
.el .SS "\f(CW$client\fP\->set_complete_fn($subref)"
.IX Subsection "$client->set_complete_fn($subref)"
Set callback function when a task is complete. No return value.
.ie n .SS "$client\->set_fail_fn($subref)"
.el .SS "\f(CW$client\fP\->set_fail_fn($subref)"
.IX Subsection "$client->set_fail_fn($subref)"
Set callback function when a task has failed. No return value.
.ie n .SS "$client\->set_status_fn($subref)"
.el .SS "\f(CW$client\fP\->set_status_fn($subref)"
.IX Subsection "$client->set_status_fn($subref)"
Set callback function when there is a status packet for a task. No return value.
.ie n .SS "$client\->set_warning_fn($subref)"
.el .SS "\f(CW$client\fP\->set_warning_fn($subref)"
.IX Subsection "$client->set_warning_fn($subref)"
Set callback function when there is a warning packet for a task.
No return value.
.ie n .SS "$client\->\fIerror()\fP"
.el .SS "\f(CW$client\fP\->\fIerror()\fP"
.IX Subsection "$client->error()"
Return an error string for the last error encountered.
.ie n .SS "$client\->\fIdo_status()\fP"
.el .SS "\f(CW$client\fP\->\fIdo_status()\fP"
.IX Subsection "$client->do_status()"
Get the status for the running task. Returns a list with the percent complete
numerator and denominator.
.ie n .SS "$client\->job_status($job_handle)"
.el .SS "\f(CW$client\fP\->job_status($job_handle)"
.IX Subsection "$client->job_status($job_handle)"
Get the status for a background job. Returns a list with 5 entries: standard
gearman return value, boolean indicating the know status, boolean indicating
the running status, and the precent complete numerator and denominator.
.ie n .SS "$client\->\fIwait()\fP"
.el .SS "\f(CW$client\fP\->\fIwait()\fP"
.IX Subsection "$client->wait()"
When in non-blocking I/O mode, wait for activity from one of the servers.
.ie n .SS "$client\->\fIclear_fn()\fP"
.el .SS "\f(CW$client\fP\->\fIclear_fn()\fP"
.IX Subsection "$client->clear_fn()"
Clear all task callback functions.
.SH "CALLBACKS"
.IX Header "CALLBACKS"
Please make sure that callback functions always explicitly return a valid
gearman_return_t value. An implicitly returned value, for example from a print
statement can cause the client connection to abort.
.SH "BUGS"
.IX Header "BUGS"
Any in libgearman plus many others of my own.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2009\-2010 Dennis Schoen
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.9 or,
at your option, any later version of Perl 5 you may have available.
.SH "WARRANTY"
.IX Header "WARRANTY"
This is free software. \s-1IT\s0 \s-1COMES\s0 \s-1WITHOUT\s0 \s-1WARRANTY\s0 \s-1OF\s0 \s-1ANY\s0 \s-1KIND\s0.
.SH "LICENSE"
.IX Header "LICENSE"
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Dennis Schoen <dennis@blogma.de>
